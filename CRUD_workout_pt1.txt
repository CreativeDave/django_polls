# ================================================================================
#   If I want to be a proficient developer in the django framework, I should
#   understand how data is created, read, updated, and deleted on a practical
#   level.

#   The following are simple command line exercises I was practicing to answer
#   the questions, "how are these operations handled in the database?" and,
#   "how is python used in the django API to execute them?"

#   These drills were a lot of fun, and resulted in a  much clearer discernment
#   between speaking of data in the abstract and in terms of technical operations.
#   
#   I chose to save this as a text file instead of the original python file to 
#   avoid the confusion of it being executed in its entirety.    
# =================================================================================

#Preworkout:

    # Open shell and import classes
python manage.py shell
from polls.models import Question, Choice
from django.utils import timezone

    # Check the current objects stored for the two classes. 
>>> Question.objects.all()
    <QuerySet []>
>>> Choice.objects.all()
    <QuerySet []>
    
    # Question class has variables question_text, and pub_date.
    # Insert data into question_text and pub_date to create Question object.
>>> Question(question_text='whats up?', pub_date=timezone.now()).save()
    <Question: whats up?>
    
    # Choice class has variables choice_text, votes, and question as fk.
    # Insert data into choice_text, votes, and question_id to create Choice object.
>>> Choice(choice_text='nada', votes=0, question_id=1).save()
    <Choice: not much>
    
    # Lets see where and how these objects are being stored in the db.
    # CTRL D exit shell. Open sqlite3.
sqlite3 db.sqlite3
    # view all tables in db.
sqlite> .tables
auth_group                  django_admin_log          
auth_group_permissions      django_content_type       
auth_permission             django_migrations         
auth_user                   django_session            
auth_user_groups            polls_choice              
auth_user_user_permissions  polls_question

    # Checkout those last two tables, polls_question and polls_choice.
    # Make data more readable by turning on columns and headers
sqlite> .mode columns
sqlite> .headers on

sqlite> SELECT * FROM polls_question;

id          question_text  pub_date                  
----------  -------------  --------------------------
1           whats up?      2019-03-23 23:35:27.273333

sqlite> SELECT * FROM polls_choice;

id          choice_text  votes       question_id
----------  -----------  ----------  -----------
1           nada         0           1          

    # Observe classes from models.py become tables in the db.
    # Observe class variables become the tables attributes.
    # id from polls_question is one-to-many fk with question_id.

# BEGIN Workout:
>>> from polls.models import *
>>> from django.utils import timezone

#Set 1

    # rep 1 insert data into question_text and pub_date to create Question object.
Question(question_text="whats your name?", pub_date=timezone.now()).save()
    # rep 2 view all question objects. Observe how objects are derived.
>>> Question.objects.all()
<QuerySet [<Question: whats up?>, <Question: whats your name?>]>
    # rep 3 insert data for Choice class objects, observe fk question_id
>>> Choice(choice_text="Dave", votes=0, question_id=2).save()
    # rep 4 view all choices. Which table and column? question_id? 
>>> Choice.objects.all()
<QuerySet [<Choice: nada>, <Choice: Dave>]>
    # rep 5 assign variable to question we just created using id attribute
>>> q=Question.objects.get(id=2)
    # rep 6 view choices. observe db is filtering fk question_id = 2
>>> q.choice_set.all()
<QuerySet [<Choice: Dave>]>

#Set 2

    # rep 1 create another question
>>> Question(question_text="whats the time?", pub_date=timezone.now()).save()
    # rep 2 create a choice, note fk question_id
>>> Choice(choice_text="noon", votes=0, question_id=3).save()
    # rep 3 create another choice
>>> Choice(choice_text="midnight", votes=0, question_id=3).save()
    # rep 4 view all questions. how is id being handled for each in db?
>>> Question.objects.all()
    <QuerySet [<Question: whats up?>, <Question: whats your name?>,
               <Question: whats the time?>]>
    # rep 5 assign variable to question, using primary key this time
>>> q=Question.objects.get(pk=3)
    # rep 6 view all related choices. observe how choice_set filters question_id = 3  
>>> q.choice_set.all()
    <QuerySet [<Choice: noon>, <Choice: midnight>]>
    # rep 7 change question text and save
>>> q.question_text="what time is it?"
>>> q.save()

#Set 3

    # rep 1 create another question
>>> Question(question_text="favorite color?", pub_date=timezone.now()).save()
    # rep 2 create a choice
>>> Choice(choice_text="blue", votes=0, question_id=4).save()
    # rep 3 create another choice
>>> Choice(choice_text="green", votes=0, question_id=4).save()
    # rep 4 view Question class object data with id 4
>>> Question.objects.filter(id=4)
    <QuerySet [<Question: favorite color?>]>
    # rep 5 view choices for this question. How is this being filtered?
>>> Question.objects.get(id=4).choice_set.all()
    <QuerySet [<Choice: blue>, <Choice: green>]>
    # rep 6 select choice blue, and assign it a variable
>>> c=Question.objects.get(pk=4).choice_set.get(choice_text="blue")
    # rep 7 change the value to red and save
>>> c.choice_text="red"
>>> c.save()
    # rep 8 view choices again for this question
>>> Question.objects.get(id=4).choice_set.all()
    <QuerySet [<Choice: red>, <Choice: green>]>
    # rep 9 count the choices. observe db is only filtering on fk 
>>> Question.objects.get(id=4).choice_set.count()
2
    # rep 10 filter choice_set using built-in functions  
>>> Question.objects.get(id=4).choice_set.filter(choice_text__startswith='green')
    <QuerySet [<Choice: green>]>
    # rep 11 assign all data from question class objects to variable 
>>> q=Question.objects.all()
    # rep 12 delete all Question objects. 
>>> q.delete()
    (10, {'polls.Choice': 6, 'polls.Question': 4})
    # check all questions 
>>> Question.objects.all()
<QuerySet []>

#Set 4

# after dropping all the objects (deleting rows from tables), we can see how SQLite
# handles storing data using the sqlite command line interface. go to CRUD workout pt 2.


















